---
title: "Qx_calculation"
author: "Jennifer Blanc"
date: "4/26/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Notation

L = number of sites  
n = number of total inidividuals  
k = number of populations  
$n_k$ = number of individuals in subpopulation k  

## Population Qx using only population infomation

As described by Berg and Coop 2014: 

$$Q_x = \frac{\vec{Z}'^TF^{-1}\vec{Z}}{2V_a}$$

To compute F:

$$F = \frac{1}{L-1} TGSG^TT^T$$ 

In the two population case: 

$$F = \frac{1}{4*(L-1)} \sum_{l=1}^L \frac{(f_{1,l} - f_{2,l})^2}{\bar{f_l} (1-\bar{f})}$$

```{r}
calc_Qx <- function(ms, k, L, L_gwas) {
  
  # Draw alleles from Beta
  #p_start <- rep(0.5, L)
  p_start <- rbeta(L, 1,3)
  p_start_gwas <- rbeta(L_gwas, 1,3)
  
  # Evolve GWAS alleles (ms = mean shift to add direction to frequency change)
  p1GWAS <- p_start_gwas + rnorm(L_gwas, ms, sqrt((p_start_gwas)*(1-p_start_gwas)* 0.01))
  p2GWAS <- p_start_gwas + rnorm(L_gwas, -ms, sqrt((p_start_gwas)*(1-p_start_gwas) *0.01))
  rm <- which(p1GWAS < 0 | p1GWAS > 1 | p2GWAS < 0 | p2GWAS > 1)
  if (length(rm) > 0) {
    p1GWAS <- p1GWAS[-rm]
    p2GWAS <- p2GWAS[-rm]    
  }
  
  # Evolve neautral alleles vias drift
  p1N <- p_start + rnorm(L, 0, sqrt((p_start_gwas)*(1-p_start_gwas)* 0.01))
  p2N <- p_start + rnorm(L, 0, sqrt((p_start_gwas)*(1-p_start_gwas)* 0.01))
  rm <- which(p1N < 0 | p1N > 1 | p2N < 0 | p2N > 1)
  if (length(rm) > 0) {
    p1N <- p1N[-rm]
    p2N <- p2N[-rm]
  }
  
  # Compute mean PGS in each population 
  Z1 <- 2 * sum(p1GWAS)
  Z2 <- 2 * sum(p2GWAS)
  
  # Mean centering matrix 
  Tmat <- matrix(-1/k, nrow = 1, ncol = 2)
  diag(Tmat) <- (k-1)/k
  
  # Mean center PGS
  Zp <- Tmat %*% c(Z1, Z2)
  
  # Compute F matrix 
  G <- rbind(p1N, p2N)
  S <- matrix(0, ncol(G),ncol(G))
  diag(S) <- 1 / (colMeans(G) * (1 - colMeans(G)))
  Fmat <- (1/(ncol(G)-1)) * (Tmat %*% G %*% S %*% t(G) %*% t(Tmat))
  
  # Compute Va 
  G_gwas <- rbind(p1GWAS, p2GWAS)
  Va <- sum(2* (colMeans(G_gwas) * (1 - colMeans(G_gwas))))
  
  # Compute Qx
  Qx <- (t(Zp) %*% solve(Fmat) %*% Zp) / (2*Va)
  return(Qx[1,1])
}
```

Neutral Case
```{r}
vecQx <- matrix(rep(0, 10000))
pvals <- rep(0, 10000)
for(i in 1:10000) {
  vecQx[i] <- calc_Qx(0, 2, 100, 100)
  pvals[i] <- pchisq(vecQx[i],1, lower.tail = F)
}

mean(vecQx)
hist(pvals)
```

Selection Case
```{r}
vecQx <- matrix(rep(0, 10000))
pvals <- rep(0, 10000)
for(i in 1:10000) {
  vecQx[i] <- calc_Qx(0.005, 2, 100, 100)
  pvals[i] <- pchisq(vecQx[i],1, lower.tail = F)
}

mean(vecQx)
hist(pvals)
```

## Population Qx using individual information

Exact same procedure as above but first generate individuals and re-estimate allele frequencies from genotype matrix  

```{r}
make_genotype_matrix <- function(p, n, L) {
  G <- matrix(NA, nrow = n, ncol = L)
  for (i in 1:length(p)) {
    G[,i] <- rbinom(n,2,p[i])
  }
  return(G)
}

calc_Qx1 <- function(ms, k, n, L, L_gwas) {
  
  # Draw alleles from Beta
  p_start <- rbeta(L, 1,3)
  p_start_gwas <- rbeta(L_gwas, 1,3)
  
  # Evolve GWAS alleles (ms = mean shift to add direction to frequency change)
  p1GWAS <- p_start_gwas + rnorm(L_gwas, ms, sqrt((p_start_gwas)*(1-p_start_gwas)* 0.01))
  p2GWAS <- p_start_gwas + rnorm(L_gwas, -ms, sqrt((p_start_gwas)*(1-p_start_gwas) *0.01))
  rm <- which(p1GWAS < 0 | p1GWAS > 1 | p2GWAS < 0 | p2GWAS > 1)
  if (length(rm) > 0) {
    p1GWAS <- p1GWAS[-rm]
    p2GWAS <- p2GWAS[-rm]    
  }
  
  # Evolve neautral alleles vias drift
  p1N <- p_start + rnorm(L, 0, sqrt((p_start_gwas)*(1-p_start_gwas)* 0.01))
  p2N <- p_start + rnorm(L, 0, sqrt((p_start_gwas)*(1-p_start_gwas)* 0.01))
  rm <- which(p1N < 0 | p1N > 1 | p2N < 0 | p2N > 1)
  if (length(rm) > 0) {
    p1N <- p1N[-rm]
    p2N <- p2N[-rm]
  }
  
  # Make Genotype matrix for GWAS alleles by drawing from population 
  i1GWAS <- make_genotype_matrix(p1GWAS, n/2, length(p1GWAS))
  i2GWAS <- make_genotype_matrix(p2GWAS, n/2, length(p2GWAS))
  
  # Make Genotype matrix for neautral alleles by drawing from population 
  i1N <- make_genotype_matrix(p1N, n/2, length(p1N))
  i2N <- make_genotype_matrix(p2N, n/2, length(p2N))
  
  # Neutral Gentotype Matrix 
  G <- rbind(i1N, i2N)/2
  if (length(which(colSums(G) == 0)) > 0 | length(which(colSums(G) == nrow(G))) > 0 ){
    if (length(which(colSums(G) == 0)) > 0) { G <- G[, -which(colSums(G) == 0)]}
    if (length(which(colSums(G) == nrow(G))) > 0) {G <- G[, -which(colSums(G) == nrow(G))]}
  }
  G_ns <- G
  G <- scale(G, scale = F)
  
  # GWAS Gentotype Matrix 
  G_gwas <- rbind(i1GWAS, i2GWAS)/2
  if (length(which(colSums(G_gwas) == 0)) > 0 | length(which(colSums(G_gwas) == nrow(G_gwas))) > 0 ){
    if (length(which(colSums(G_gwas) == 0)) > 0) { G_gwas <- G_gwas[, -which(colSums(G_gwas) == 0)]}
    if (length(which(colSums(G_gwas) == nrow(G_gwas))) > 0) {G_gwas <- G_gwas[, -which(colSums(G_gwas) == nrow(G_gwas))]}
  }
  G_gwas_ns <- G_gwas
  G_gwas <- scale(G_gwas, scale = F)
  
  # Calc allele frequencies  
  p1GWAS <- colMeans(G_gwas_ns[1:(n/2), ])
  p2GWAS <- colMeans(G_gwas_ns[(n/2):n, ])
  p1N <- colMeans(G_ns[1:(n/2), ])
  p2N <- colMeans(G_ns[(n/2):n, ])
  
   # Compute mean PGS 
  Z1 <- 2 * sum(p1GWAS)
  Z2 <- 2 * sum(p2GWAS)
  
  # Mean centering matrix 
  Tmat <- matrix(-1/k, nrow = 1, ncol = 2)
  diag(Tmat) <- (k-1)/k
  
  # Mean center PGS
  Zp <- Tmat %*% c(Z1, Z2)
  
  # Compute F matrix 
  G <- rbind(p1N, p2N)
  S <- matrix(0, ncol(G),ncol(G))
  diag(S) <- 1 / (colMeans(G) * (1 - colMeans(G)))
  Fmat <- (1/(ncol(G)-1)) * (Tmat %*% G %*% S %*% t(G) %*% t(Tmat))
  
  # Compute Va 
  G_gwas <- rbind(p1GWAS, p2GWAS)
  Va <- sum(2* (colMeans(G_gwas) * (1 - colMeans(G_gwas))))
  
  # Compute Qx
  Qx <- (t(Zp) %*% solve(Fmat) %*% Zp) / (2*Va)
  return(Qx[1,1])
}
```

Neutral 
```{r}
vecQx <- matrix(rep(0, 10000))
pvals <- rep(0, 10000)
for(i in 1:10000) {
  vecQx[i] <- calc_Qx1(0, 2, 100, 100, 500)
  pvals[i] <- pchisq(vecQx[i], 1, lower.tail = F)
}

mean(vecQx)
hist(pvals)
```


## Population Qx using individual information

According to Josephs et al 2019:

$$Q_x = \frac{Z_{pop}^T K_{pop}^{-1}Z_{pop}}{2Va}$$


Where, 

$$K_{pop} = H^TKH$$ 

and, 

$$K = cov(\frac{TG}{\sqrt{\bar{p}(1-\bar{p})}})$$

The eigen vectors of $K$ are the same as doing svd of the mean centered genotype matrix.  

Doing math for the two population case we can figure out that, 

$$K_{pop} = \frac{1}{\sqrt{\overline{p(1-p)}}} \frac{1}{n_1^2} \sum_{i=1}^{n_k}  \sum_{j=1}^{n_k} \sum_{l=1}^L (X_{il} - 2\bar{p_l})(X_{jl} -2\bar{p_l})$$


```{r}
make_genotype_matrix <- function(p, n, L) {
  G <- matrix(NA, nrow = n, ncol = L)
  for (i in 1:length(p)) {
    G[,i] <- rbinom(n,2,p[i])
  }
  return(G)
}
G <- make_genotype_matrix(rbeta(1000, 1, 3), 100, 1000)

# Compute K 
mean_het <- mean((colMeans(G)/2) * (1 - (colMeans(G)/2)))
Tmat <- matrix(-1/100, nrow = 100-1, ncol = 100)
diag(Tmat) <- (100-1)/100
K = (1/sqrt(mean_het)) * ((Tmat %*% G) %*% t((Tmat %*% G)))

# Compute Kpop
H <- matrix(0, nrow = (100-1), ncol = 1)
H[1:(100/2), 1] <- 1/(100/2)
Kpop <-(t(H) %*% K %*% H)

# Check that the eigen vectors of K are the same as eigen vectors from SVD of G
SVD_c <- svd(scale(G, scale=F)[1:99,])
u_svd <- SVD_c$u
myE <- eigen(K) 
u_E <- myE$vectors

# Check alternate definition of Kpop - not quite the same? 
v <- c()
for (i in 1:50){
  for (j in 1:50) {
    v <- c(v, sum((G[i,] - colMeans(G)) * ((G[j,] - colMeans(G))))) 
  }
}
Kpop2 <- (1/sqrt(het)) * (1/(50^2))* sum(v) 
```


```{r}
make_genotype_matrix <- function(p, n, L) {
  G <- matrix(NA, nrow = n, ncol = L)
  for (i in 1:length(p)) {
    G[,i] <- rbinom(n,2,p[i])
  }
  return(G)
}

calc_Qx2 <- function(ms, k, n, L, L_gwas) {
  
 # Draw alleles from Beta
  p_start <- rbeta(L, 1,3)
  p_start_gwas <- rbeta(L_gwas, 1,3)
  
  # Evolve GWAS alleles (ms = mean shift to add direction to frequency change)
  p1GWAS <- p_start_gwas + rnorm(L_gwas, ms, sqrt((p_start_gwas)*(1-p_start_gwas)* 0.01))
  p2GWAS <- p_start_gwas + rnorm(L_gwas, -ms, sqrt((p_start_gwas)*(1-p_start_gwas) *0.01))
  rm <- which(p1GWAS < 0 | p1GWAS > 1 | p2GWAS < 0 | p2GWAS > 1)
  if (length(rm) > 0) {
    p1GWAS <- p1GWAS[-rm]
    p2GWAS <- p2GWAS[-rm]    
  }
  
  # Evolve neautral alleles vias drift
  p1N <- p_start + rnorm(L, 0, sqrt((p_start_gwas)*(1-p_start_gwas)* 0.01))
  p2N <- p_start + rnorm(L, 0, sqrt((p_start_gwas)*(1-p_start_gwas)* 0.01))
  rm <- which(p1N < 0 | p1N > 1 | p2N < 0 | p2N > 1)
  if (length(rm) > 0) {
    p1N <- p1N[-rm]
    p2N <- p2N[-rm]
  }
  
  # Make Genotype matrix for GWAS alleles by drawing from population 
  i1GWAS <- make_genotype_matrix(p1GWAS, n/2, length(p1GWAS))
  i2GWAS <- make_genotype_matrix(p2GWAS, n/2, length(p2GWAS))
  
  # Make Genotype matrix for neautral alleles by drawing from population 
  i1N <- make_genotype_matrix(p1N, n/2, length(p1N))
  i2N <- make_genotype_matrix(p2N, n/2, length(p2N))
  
  # Neutral Gentotype Matrix 
  G <- rbind(i1N, i2N)/2
  if (length(which(colSums(G) == 0)) > 0 | length(which(colSums(G) == nrow(G))) > 0 ){
    if (length(which(colSums(G) == 0)) > 0) { G <- G[, -which(colSums(G) == 0)]}
    if (length(which(colSums(G) == (2*nrow(G)))) > 0) {G <- G[, -which(colSums(G) == nrow(G))]}
  }
  G_ns <- G
  G <- scale(G, scale = F)
  
  # GWAS Gentotype Matrix 
  G_gwas <- rbind(i1GWAS, i2GWAS)/2
  if (length(which(colSums(G_gwas) == 0)) > 0 | length(which(colSums(G_gwas) == nrow(G_gwas))) > 0 ){
    if (length(which(colSums(G_gwas) == 0)) > 0) { G_gwas <- G_gwas[, -which(colSums(G_gwas) == 0)]}
    if (length(which(colSums(G_gwas) == (nrow(G_gwas)*2))) > 0) {G_gwas <- G_gwas[, -which(colSums(G_gwas) == nrow(G_gwas))]}
  }
  G_gwas_ns <- G_gwas
  G_gwas <- scale(G_gwas, scale = F)
  
  # Compute individual PGS, mean center and drop last value
  Z <- c(rowSums(G_gwas_ns))
  Zp <- scale(Z, scale = F)[1:(n-1)]
  
  # Mean centering matrix 
  Tmat <- matrix(-1/n, nrow = n-1, ncol = n)
  diag(Tmat) <- (n-1)/n
  
  # Compute K
  het <- mean((colMeans(G_ns) * (1 - colMeans(G_ns))))
  TG <- Tmat %*% (G_ns)
  TG_s <- (1/sqrt(het)) *  (TG)
  K <- TG_s %*% t(TG_s)
  #K <- (1/(ncol(G)-1)) * G[1:99,] %*% t(G[1:99,])
  
  #S <- matrix(0, ncol(G), ncol(G))
  #diag(S) <- (colMeans(G_ns) * (1 - colMeans(G_ns)))
  #K <- (1/(ncol(G)-1)) * Tmat %*% (G_ns) %*% S %*% t(G_ns) %*% t(Tmat)
  
  # Compute Kpop
  H <- matrix(0, nrow = (n-1), ncol = 1)
  H[1:(n/2), 1] <- 1/(n/2)
  Kpop <-(t(H) %*% K %*% H)
  
  #v <- c()
  #for (i in 1:50){
  #  for (j in 1:50) {
  #    v <- c(v, sum((G_ns[i,] - colMeans(G_ns)) * (G_ns[j,] - colMeans(G_ns)))) 
  #  }
  #}
  #Kpop2 <- (1/het) * (1/(50^2))* sum(v) 
  
  # Compute Zpop
  Zpop <- t(H) %*% Zp
  
  # Compute Va 
  Va <- sum(2* ((colMeans(G_gwas_ns)) * (1 - (colMeans(G_gwas_ns)))))
  
  # Compute Qx
  Qx <- (t(Zpop) %*% solve(Kpop) %*% Zpop) / (2*Va)
  return(Qx[1,1])
}

vecQx <- matrix(rep(0, 500))
pvals <- rep(0, 500)
for(i in 1:500) {
  vecQx[i] <- calc_Qx2(0, 2, 100, 100, 100)
  pvals[i] <- pchisq(vecQx[i],1, lower.tail = F)
}

mean(vecQx)
hist(pvals)
```
