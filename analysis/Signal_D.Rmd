---
title: "Real_Signal_D"
author: "Jennifer Blanc"
date: "2023-02-28"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(data.table)
library(pgenlibr)
```

Read in genotype matrices 
```{r}
# Function to read in genotype matrix for a set of variants
read_genos <- function(geno_prefix, betas) {

  pvar <- pgenlibr::NewPvar(paste0(geno_prefix, ".pvar"))
  d1 <- pgenlibr::NewPgen(paste0(geno_prefix, ".pgen"))
  var.ids <- betas$ID
  var.indx <- rep(0, length(var.ids))
  for (i in 1:length(var.indx)) {
    var.indx[i] <- pgenlibr::GetVariantsById(pvar,var.ids[i])
  }
  X <- ReadList(d1,var.indx, meanimpute=F)
  colnames(X) <- var.ids

  return(X)
}

vars <- fread("../output/Simulate_Genotypes/4PopSplit/D1/genos-gwas_common.pvar", skip = 200)
G <- read_genos("../output/Simulate_Genotypes/4PopSplit/D1/genos-gwas_common", vars)
#G <- rbind(G[1:500,], G[39501:40000,])
X <- read_genos("../output/Simulate_Genotypes/4PopSplit/D1/genos-test_common", vars)
```

```{r}
#### Set change-able parameters###
ncausal <- 1
prob <- 1
m <- nrow(G)
n <- nrow(X)
nsnps <- ncol(G)


# Get allele frequency diff in TP
pC <- colMeans(X[1:1000,])/2
pD <- colMeans(X[1001:2000,])/2
diff <- pD - pC

# Generate effect sizes so there is a true signal
indx <- sample(seq(1, ncol(G)), ncausal)
diff.causal <- diff[indx]
B <- rnorm(ncausal, 0, 1)
for (i in 1:ncausal){
  if (diff.causal[i] >= 0) {
    B[i] <- sample(c(-1, 1),1, prob = c((1-prob), prob)) * abs(B[i])
  } else {
    B[i] <- sample(c(1, -1),1, prob = c((1-prob), prob)) * abs(B[i])
  }
}
betas <- rep(0, nsps)
betas[indx] <- B

# Mean center both genotype matrices
G <- scale(G, scale = F)
X <- scale(X, scale = F)

# Calculate True GV
gwas.gvs <- G[, indx]%*%as.matrix(B)
test.gvs <- X[, indx]%*%as.matrix(B)

# Simulate Phenotypes
phenos <- gwas.gvs+rnorm(m)

# Make 2 pop test vector
tvec <- scale(c(rep(0,n/2),rep(1,n/2)))

# Compute FGr
r.all <- t(X) %*% tvec
Gvar <- apply(G, 2, var)
FGr <- G %*% (r.all/Gvar)
FGr <- scale(FGr)

# Compute Bhat including Tm
Tm_Bhat <- numeric()
for(k in 1:nsnps){
  Tm_Bhat[k] <- lm(phenos~G[,k] + FGr)$coef[2]
}

r.causal <- r.all[indx]
true.q <- (1/(n-1)) * (B %*% r.causal)
S.q <- (1/(n-1)) * (Tm_Bhat[indx] %*% r.causal)
L.q <- (1/(n-1)) * (Tm_Bhat %*% r.all)

```


```{r}
#### Only once #####

# Get allele frequency diff in TP
pC <- colMeans(X[1:1000,])/2
pD <- colMeans(X[1001:2000,])/2
diff <- pD - pC

# Mean center both genotype matrices
G <- scale(G, scale = F)
X <- scale(X, scale = F)

# Make 2 pop test vector
tvec <- scale(c(rep(0,n/2),rep(1,n/2)))

# Compute FGr
r.all <- t(X) %*% tvec
Gvar <- apply(G, 2, var)
FGr <- G %*% (r.all/Gvar)
FGr <- scale(FGr)

# Set parameters
prob <- 1
m <- nrow(G)
n <- nrow(X)
L <- ncol(G)
ncausal_list <- c(1, 100, 500, 1000)

########################

out <- matrix(NA, nrow = length(ncausal_list), ncol = 4)

for (j in 1:length(ncausal_list)) {
  
  print(j)
  
  ncausal <- ncausal_list[j]
  
  # Generate effect sizes so there is a true signal
  indx <- sample(seq(1, L), ncausal)
  diff.causal <- diff[indx]
  B <- rnorm(ncausal, 0, L/ncausal)
  for (i in 1:ncausal){
    if (diff.causal[i] >= 0) {
      B[i] <- sample(c(-1, 1),1, prob = c((1-prob), prob)) * abs(B[i])
    } else {
      B[i] <- sample(c(1, -1),1, prob = c((1-prob), prob)) * abs(B[i])
    }
  }
  betas <- rep(0, nsps)
  betas[indx] <- B
  
  # Calculate True GV
  gwas.gvs <- G[, indx]%*%as.matrix(B)
  test.gvs <- X[, indx]%*%as.matrix(B)

  # Simulate Phenotypes
  phenos <- gwas.gvs+rnorm(m)
  
  # Compute Bhat including Tm
  Tm_Bhat <- numeric()
  for(k in 1:nsnps){
    Tm_Bhat[k] <- lm(phenos~G[,k] + FGr)$coef[2]
  }

  # Compute different versions of q 
  r.causal <- r.all[indx]
  true.q <- (1/(n-1)) * (B %*% r.causal)
  S.q <- (1/(n-1)) * (Tm_Bhat[indx] %*% r.causal)
  L.q <- (1/(n-1)) * (Tm_Bhat %*% r.all)

  tmp <- c(true.q, S.q, L.q, ncausal)
  out[j,] <- tmp
}
```












```{r}
## Scale genotypes together 
gwas.genos.all <- scale(G)
test.genos.all <- scale(X)

## Parameters 
nsnps <- ncol(X)
gwas.ninds <- nrow(G)
test.ninds <- nrow(X)

## Possible num causals 
num_causal <- c(5, 10, 100, 300, 500,1000, 2000)

# Make 2 pop test vector
tvec <- scale(c(rep(0,test.ninds/2),rep(1,test.ninds/2)))

# Compute R 
r.all <- t(test.genos.all)%*%tvec/(test.ninds-1)

# Project Tvec using all sites
tmp.proj.tvec <- gwas.genos.all%*%r.all
norm <- as.numeric(t(tmp.proj.tvec)%*%tmp.proj.tvec)
proj.tvec <- tmp.proj.tvec/sqrt(norm)

# Compute PC1 
myE <-  fread("../output/Simulate_Genotypes/4PopSplit/D1/genos-gwas.eigenvec")
u1 <- myE$PC1

# Compute PC1 
myE <- eigen(gwas.genos.all %*% t(gwas.genos.all))
u1 <- myE$vectors[,1]

pC <- colMeans(X[1:1000,])/2
pD <- colMeans(X[1001:2000,])/2
diff <- pD - pC

true_q <- rep(0, length(num_causal))
real.stat <- rep(0, length(num_causal))
real.stat.pca <- rep(0, length(num_causal))
real.stat.s <- rep(0, length(num_causal))
```



```{r}
for (i in 1:length(num_causal)) {
  
  print(i)
  
  # Draw effect sizes
  B <- rep(0, nsnps)
  indx <- sample(which(diff > 0),num_causal[i] )
  betas <- abs(rnorm(num_causal[i],0,nsnps/num_causal[i]))
  B[indx] <- betas
  
  # Separate causal and non-causal sites
  test.genos.causals <- test.genos.all[,indx]
  test.genos.noncausals <- test.genos.all[,-indx]

  # Separate causal and non-causal sites
  gwas.genos.causals <- gwas.genos.all[,indx]
  gwas.genos.noncausals <- gwas.genos.all[,-indx]

  # Compute GVs and Phenos 
  gwas.gvs <- gwas.genos.causals%*%betas
  pheno.raw <- gwas.gvs+rnorm(gwas.ninds)
  phenos <- scale(pheno.raw)

  # Compute R 
  r.causals <- t(test.genos.causals)%*%tvec/(test.ninds-1)
  
  # Compute Bhat
  adj.lm.betas <- numeric()
  for(k in 1:nsnps){
    adj.lm.betas[k] <- lm(phenos~gwas.genos.all[,k] + proj.tvec)$coef[2]
  }

  # Compute Bhat PCA 
  adj.lm.betas.pca <- numeric()
  for(k in 1:nsnps){
    adj.lm.betas.pca[k] <- lm(phenos~gwas.genos.all[,k] + u1)$coef[2]
  }

  true_q[i] <- t(r.causals)%*%(betas / sd(pheno.raw))
  real.stat.s[i] <- t(r.causals)%*% as.matrix(adj.lm.betas[indx])
  real.stat[i] <- t(r.all)%*%as.matrix(adj.lm.betas)
  real.stat.pca[i] <- t(r.all)%*%as.matrix(adj.lm.betas.pca)
  
}
```


