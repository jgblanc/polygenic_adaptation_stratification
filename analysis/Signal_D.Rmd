---
title: "Real_Signal_D"
author: "Jennifer Blanc"
date: "2023-02-28"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(data.table)
library(pgenlibr)
```

Read in genotype matrices 
```{r}
# Function to read in genotype matrix for a set of variants
read_genos <- function(geno_prefix, betas) {

  pvar <- pgenlibr::NewPvar(paste0(geno_prefix, ".pvar"))
  d1 <- pgenlibr::NewPgen(paste0(geno_prefix, ".pgen"))
  var.ids <- betas$ID
  var.indx <- rep(0, length(var.ids))
  for (i in 1:length(var.indx)) {
    var.indx[i] <- pgenlibr::GetVariantsById(pvar,var.ids[i])
  }
  X <- ReadList(d1,var.indx, meanimpute=F)
  colnames(X) <- var.ids

  return(X)
}

vars <- fread("../output/Simulate_Genotypes/4PopSplit/D1/genos-gwas_common.pvar", skip = 200)
G <- read_genos("../output/Simulate_Genotypes/4PopSplit/D1/genos-gwas_common", vars)
#G <- rbind(G[1:500,], G[39501:40000,])
X <- read_genos("../output/Simulate_Genotypes/4PopSplit/D1/genos-test_common", vars)
```

```{r}
#### Set change-able parameters###
ncausal <- 100
prob <- 1
m <- nrow(G)
n <- nrow(X)
nsnps <- ncol(G)


# Get allele frequency diff in TP
pC <- colMeans(X[1:1000,])/2
pD <- colMeans(X[1001:2000,])/2
diff <- pD - pC

# Generate effect sizes so there is a true signal
indx <- sample(seq(1, ncol(G)), ncausal)
diff.causal <- diff[indx]
B <- rnorm(ncausal, 0, 1)
for (i in 1:ncausal){
  if (diff.causal[i] >= 0) {
    B[i] <- sample(c(-1, 1),1, prob = c((1-prob), prob)) * abs(B[i])
  } else {
    B[i] <- sample(c(1, -1),1, prob = c((1-prob), prob)) * abs(B[i])
  }
}
betas <- rep(0, nsnps)
betas[indx] <- B

# Mean center both genotype matrices
G <- scale(G, scale = F)
X <- scale(X, scale = F)

# Calculate True GV
gwas.gvs <- G[, indx]%*%as.matrix(B)
test.gvs <- X[, indx]%*%as.matrix(B)

# Simulate Phenotypes
phenos <- gwas.gvs+rnorm(m)

# Make 2 pop test vector
tvec <- scale(c(rep(0,n/2),rep(1,n/2)))

# Compute FGr
r.all <- t(X) %*% tvec
Gvar <- apply(G, 2, var)
FGr <- G %*% (r.all/Gvar)
FGr <- scale(FGr)

# Compute Bhat including Tm
Tm_Bhat <- numeric()
for(k in 1:nsnps){
  Tm_Bhat[k] <- lm(phenos~G[,k] + FGr)$coef[2]
}

# Compute Bhat including PC1
PC_Bhat <- numeric()
u1 <- scale(PC$PC1)
u1 <- scale(c(rep(0,m/2),rep(1,m/2)))
for(k in 1:nsnps){
  PC_Bhat[k] <- lm(phenos~G[,k] + u1)$coef[2]
}

r.causal <- r.all[indx]
true.q <- (1/(n-1)) * (B %*% r.causal)
S.q <- (1/(n-1)) * (Tm_Bhat[indx] %*% r.causal)
L.q <- (1/(n-1)) * (Tm_Bhat %*% r.all)
eq <- true.q * (1 - (ncausal/nsnps))
PC_S.q <- (1/(n-1)) * (PC_Bhat[indx] %*% r.causal)
PC_L.q <- (1/(n-1)) * (PC_Bhat %*% r.all)

plot(Tm_Bhat, PC_Bhat)
abline(0,1)
```


```{r}
#### Only once #####

# Get allele frequency diff in TP
pC <- colMeans(X[1:1000,])/2
pD <- colMeans(X[1001:2000,])/2
diff <- pD - pC

# Mean center both genotype matrices
G <- scale(G, scale = F)
X <- scale(X, scale = F)

# Make 2 pop test vector
tvec <- scale(c(rep(0,n/2),rep(1,n/2)))

# Compute FGr
r.all <- t(X) %*% tvec
Gvar <- apply(G, 2, var)
FGr <- G %*% (r.all/Gvar)
FGr <- scale(FGr)

# Compute fist eigen vector
myE <- eigen(G %*% t(G))

# Set parameters
prob <- 1
m <- nrow(G)
n <- nrow(X)
L <- ncol(G)
ncausal_list <- c(1, 100, 500, 1000)

########################

out <- matrix(NA, nrow = length(ncausal_list), ncol = 4)

for (j in 1:length(ncausal_list)) {
  
  print(j)
  
  ncausal <- ncausal_list[j]
  
  # Generate effect sizes so there is a true signal
  indx <- sample(seq(1, L), ncausal)
  diff.causal <- diff[indx]
  B <- rnorm(ncausal, 0, L/ncausal)
  for (i in 1:ncausal){
    if (diff.causal[i] >= 0) {
      B[i] <- sample(c(-1, 1),1, prob = c((1-prob), prob)) * abs(B[i])
    } else {
      B[i] <- sample(c(1, -1),1, prob = c((1-prob), prob)) * abs(B[i])
    }
  }
  betas <- rep(0, nsps)
  betas[indx] <- B
  
  # Calculate True GV
  gwas.gvs <- G[, indx]%*%as.matrix(B)
  test.gvs <- X[, indx]%*%as.matrix(B)

  # Simulate Phenotypes
  phenos <- gwas.gvs+rnorm(m)
  
  # Compute Bhat including Tm
  Tm_Bhat <- numeric()
  for(k in 1:nsnps){
    Tm_Bhat[k] <- lm(phenos~G[,k] + FGr)$coef[2]
  }

  # Compute different versions of q 
  r.causal <- r.all[indx]
  true.q <- (1/(n-1)) * (B %*% r.causal)
  S.q <- (1/(n-1)) * (Tm_Bhat[indx] %*% r.causal)
  L.q <- (1/(n-1)) * (Tm_Bhat %*% r.all)

  tmp <- c(true.q, S.q, L.q, ncausal)
  out[j,] <- tmp
}
```












```{r}
## Scale genotypes together 
gwas.genos.all <- scale(G)
test.genos.all <- scale(X)

## Parameters 
nsnps <- ncol(X)
gwas.ninds <- nrow(G)
test.ninds <- nrow(X)

## Possible num causals 
num_causal <- c(5, 10, 100, 300, 500,1000, 2000)

# Make 2 pop test vector
tvec <- scale(c(rep(0,test.ninds/2),rep(1,test.ninds/2)))

# Compute R 
r.all <- t(test.genos.all)%*%tvec/(test.ninds-1)

# Project Tvec using all sites
tmp.proj.tvec <- gwas.genos.all%*%r.all
norm <- as.numeric(t(tmp.proj.tvec)%*%tmp.proj.tvec)
proj.tvec <- tmp.proj.tvec/sqrt(norm)

# Compute PC1 
myE <-  fread("../output/Simulate_Genotypes/4PopSplit/D1/genos-gwas.eigenvec")
u1 <- myE$PC1

# Compute PC1 
myE <- eigen(gwas.genos.all %*% t(gwas.genos.all))
u1 <- myE$vectors[,1]

pC <- colMeans(X[1:1000,])/2
pD <- colMeans(X[1001:2000,])/2
diff <- pD - pC

true_q <- rep(0, length(num_causal))
real.stat <- rep(0, length(num_causal))
real.stat.pca <- rep(0, length(num_causal))
real.stat.s <- rep(0, length(num_causal))
```




```{r}
df <- fread("../code/Plots/Sig_Results.txt.gz")
colnames(df) <- c("rep", "true.q", "S.q", "L.q", "n.causal", "eq", "PC.S.q", "PC.L.q")
df2 <- melt(df, id.vars = c("n.causal", "rep"))

df_plot <- df2 %>% group_by(n.causal, variable) %>% summarise(q = mean(value), upper.ci = q + 1.96*(sd(value)/sqrt(n())), lower.ci= q -  1.96*(sd(value)/sqrt(n())))

ggplot(data = df_plot, aes(x = n.causal, y = q, color = variable)) + geom_point() + geom_errorbar(aes(ymin = lower.ci, ymax = upper.ci),  width = 80)
```
```{r}
PC <- fread("~/Downloads/genos-gwas.eigenvec")
```



